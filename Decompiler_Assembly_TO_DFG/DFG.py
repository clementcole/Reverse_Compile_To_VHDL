__author__ = 'clementacole75@gmail.com'
#!/usr/bin/env python3
import sys
import csv
import json
import os.path
import struct
import re
import os
import glob
import errno
import itertools
import inflect


sys.dont_write_bytecode = True
from bisect import bisect_right

#Commands for executing graphviz api to render DFG pixels.
#Please don't use Tpng options it sucks.
#instead use Tps option.
#So far Block 101, 2, were generated successfully
#Still needs some bugs fixing
#Notes !!
#	   !!
#	   \/
#      ---\  Issue #1  ==> bug fixed for regular expression
#	   ---/  Issue #2  ==> graphviz api takes longer than normal to generate .ps,
#			 Issue #3  ==> Render quality of .png files are very low
#			 Issue #4  ==> The following micro operators_X86 should be completed by next week
#						  ==>  {add, addi, mul, multi,  }
#			 Issue #5  ==> Creat_shell() function does not work properly, be advised manually execute dot command in Graphs directory
#			 Issue #6  ==> Big one combining all blocks to form the giant DFG
#			 ;Test ==> blocks.py = passed
#			 ;Blocks_recursive_generator = passed
# 			 ;*.dot_file_generator implementation passed
#			 ;Executing all *.dot files with os.system("dot -Tps *.dot -o "${filename}") = failed
#			 ;Bug within graph.write("%s -> %s"%(op, instruction[i]))
#			 ;No issues with node decorator.
#			 ;Test subject = fftX86_output
#sfdp -x Tpng data.dot > data.png
#neato -x Tpng data.dot > data.png
#sfdp -x -Goverlap = scale -Tpng test1.dot > test1.png

#Exceptions file, this would be the list of micro_ops not been implemented
input_path = 'Blocks/*'    #Hard import from the read_blocks.py module
files = glob.glob(input_path)	#Hard import from the read_blocks.py module
Henum = "enum op_nodes{\n"
Tenum = "};\n"

cmain = "int main(){"

#gmatrix 		 = []   #Graph matrix to implement adjacent list graphing
#absolute_address = []	#Absolute address
#relative_address = []	#relative address
#macro_op         = []	#macro node
#micro_ops        = []	#micro node
#dest_nodes       = []	#destination node
#sources1		 = []	#source1 node
#sources2         = []	#source2 node
#micro_instr	 	 = []
#L_list           = []

found_ops = open('found.md', 'a')
not_found_ops = open('not_found.md', 'a')
test_output = open('current_dictionary.md', 'a')
no_dfg = open('operators_with_no_dfg.txt', 'a')
#dest_node_file = open('DNF.txt', 'a')
##instructions_file = open("line.txt", 'a')
#temp_reg_file = open("temp_registers", 'a')

#output_path = "/Graphs/"
#if os.path.exists(output_path):
#	os.removedirs(output_path)
#else:
#	os.makedirs(output_path)

#graph = open('test1.dot', 'a')

#Algorithm for connecting the individual nodes for each instruction:
#If any input_node is in list_of_dest_nodes:
#	replace input_node with the node from list_of_dest_nodes
#	store new_dest_node into list_of_dest_nodes
#Else:
#	create new input_node with node_from instruction
# 	store new_dest_node into list_of_dest_nodes
'''
def initializer_graph(graph):
	file_initializer(graph, graph)
	graph.write('digraph test{\n')
	graph.write('\tsize = "4,4";\n')
'''


def EnumTableHead(cgraph):
	cgraph.write("\n%s" %(Henum))

def EnumTableTail(cgraph):
	cgraph.write("%s" %(Tenum))


def CREATE_TABLE(cgraph):
	cgraph.write("")



def __CPP_HEADER__(cgraph):
	#cgraph.write("#include \"TopHead.h\"\n\n")
	#EnumTableHead(cgraph)
	#EnumTableTail(cgraph)
	#cgraph.write()
	cgraph.write("%s" %(cmain))	
	


def __CPP_FOOTER__(cgraph):
	cgraph.write("\nreturn 0;\n}")

def __IMPLEMENT_GRAPH__(cgraph, cdot):
	cgraph.write("\nfor (size_t  i = 0; i != op_nodes.size(); ++i){\n")
	cgraph.write("\t\tsize_t j = i + 1;\n")
	cgraph.write("\t\t while (j < op_nodes.size()){\n")
	cgraph.write("\t\t\tif (dest[i] == src1[j]){\n")
	cgraph.write("\t\t\t\tif (src1[j] != \"0\"){\n")
	cgraph.write("\t\t\t\t\tgh.addEdge(i, j);\n")
	cgraph.write("\t\t\t\t\t%s<<op_nodes[i]<<\"->\"<<op_nodes[j]<<endl\n;"%(cdot))
	cgraph.write("\t\t\t\t}\n")
	cgraph.write("\t\t\t}\n")
	cgraph.write("\t\t\tif (dest[i] == src2[j]){\n")
	cgraph.write("\t\t\t\tif (src2[j] != \"0\"){\n")
	cgraph.write("\t\t\t\t\tgh.addEdge(i, j);\n")
	cgraph.write("\t\t\t\t\t%s<<op_nodes[i]<<\"->\"<<op_nodes[j]<<endl\n;"%(cdot))
	cgraph.write("\t\t\t\t}\n")
	cgraph.write("\t\t\t}\n")
	cgraph.write("\t\tj++;}\n")
	cgraph.write("}\n")
	



def finalizer_graph(graph):
	graph.write('return 0; \n}')


def process_instruction(instruction):
	micro = instruction.split(',')	#Split, might not be necessary
	ops = micro[0]		#Generate the operators string
	regs = micro[1:]	#Generate slice from instructions
	register_list = []	#register_list for generating list of registers inside list
	reg_index = 0	#
	for index in range(regs): #iterate through the slice generated by micro from the first index
		register_list[reg_index] = regs[index] #assign regs[n...]  to register_list[n+1...]
		reg_index = reg_index + 1   #increase the register's index

def push_stacks(op_node, dest, src1, src2, graph):
	graph.write("op_nodes.push_back(\"%s\");\n"%(op_node))
	graph.write("dest.push_back(\"%s\");\n"%(dest))
	graph.write("src1.push_back(\"%s\");\n"%(src1))
	graph.write("src2.push_back(\"%s\");\n"%(src2))

def __check_label__(node_label):

	#for index, node_label in enumerate(dest_node_labels):
	if node_label in dest_node_labels:
		#i = dest_node_labels.rindex(node_label)
		i = len(dest_node_labels) - dest_node_labels[::-1].index(node_label) - 1
		return i + 1
	else:
		return 0
'''
temp_registers =[	"t0d",  "t1d",  "t2d",  "t3d",  "t4d",  "t5d", "t6d", "t7d", "t8d", "t9d",
					"t0w",  "t1w",  "t2w",  "t3w",  "t4w",  "t5w", "t6w", "t7w", "t8w", "t9w",
				 	"t0",   "t1",   "t2",   "t3",   "t4",   "t5",  "t6",  "t7",  "t8",  "t9"
				 	"eax",  "rax" ]
temp_reg_shape = "point"


def graphity(block_matrix, graph):
	#for i in range(len(block_matrix)):
	#	instructions_file.write(str(block_matrix[i]))
	#	instructions_file.write(str(len(block_matrix[i])))
	#	instructions_file.write("\n")
	for i in range(len(block_matrix)):
		j = i + 1
		if len(block_matrix[i]) == 7:
			while j < len(block_matrix):
				if len(block_matrix[j]) == 7:
					if block_matrix[j][5] != '0':					  #Test if src1 isn't '0'
						if block_matrix[i][5] == block_matrix[j][4]: 
							graph.write("%s -> %s\n"%(block_matrix[i][3], block_matrix[j][3]))
					if block_matrix[j][6] != '0':					  #Test if src2 isn't '0'
						if block_matrix[i][6] == block_matrix[j][4]:	
							graph.write("%s -> %s\n"%(block_matrix[i][3], block_matrix[j][3]))
				j = j + 1
			 
'''	
			
def ADD(instruction, block, line_number, graph, graphH):
  #Generic add operator
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ADD"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0] 
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	graphH.write("%s,\n"%(op_node))
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 	






def ADDI(instruction, block, line_number, graph, graphH):
  #Add immediate operator
	#'addi'
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ADDI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op   = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 
	

def ADC(instruction, block, line_number, graph, graphH):
 #Add with carry
	#"adc"
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ADC"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 



def ADCI(instruction, block, line_number, graph, graphH):
  #Add immediate with carry
	#adci
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ADCI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "circle"
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def   SUB(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SUB"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def  SUBI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SUBI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def  MUL1S(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MUL1S"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 



def MUL1SI(instruction, block, line_number, graph, graphH):

	#'addi'
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MUL1SI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op   = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def MUL1U(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MUL1U"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)

	return block 


def MUL1UI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MUL1UI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op   = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	imm  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = imm
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def MULEL(instruction, block, line_number, graph, graphH):
  #Dest = Dest <- ProdLo
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MULEL"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op   = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	op_node   = op   + str(line_number)
	block[3] = op_node 
	block[4] = dest 
	block[5] = src1
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def MULEH(instruction, block, line_number, graph, graphH):
  #Dest = Dest <- ProdHi
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MULEH"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op   = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	op_node   = op   + str(line_number)
	block[3] = op_node 
	block[4] = dest 
	block[5] = src1 
	block.insert(6, "0")
	return block 


def DIV1(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def DIV1I(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def DIV2(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def DIV2I(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def DIVQ(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def DIVR(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def OR(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "OR"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)

	return block 


def ORI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ORI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def XOR(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "XOR"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def MXOR(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MXOR"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def XORI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ADD"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def AND(instruction, block, line_number, graph, graphH):
 #logical and operator
	#and
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "AND"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 	


def ANDI(instruction, block, line_number, graph, graphH):
 #Logical and immediate operator
	#'andi'
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ANDI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 	

## operands operators
def SLL(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SLL"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 	

def SLLI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SLLI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def SRL(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SRL"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 	


def SRLI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SRLI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def SRA(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SRA"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def SRAI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SRAI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def ROR(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ROR"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def RORI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "RORI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def RCR(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "RCR"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def RCRI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "RCRI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	imm  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def ROL(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ROL"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def ROLI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ROLI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	imm  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def RCL (instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "RCL"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def RCLI (instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "RCLI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 	

def MOV (instruction, block, line_number, graph, graphH):
  # dest = src1 <- src2
	#mov dest, src1, src2  ==> dest = src1 <- src2 ==> merge contents of src1 and src2 and store in destination address.
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MOV"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def MOVSIGN(instruction, block, line_number, graph, graphH):

	#mov dest, src1, src2  ==> dest = src1 <- src2 ==> merge contents of src1 and src2 and store in destination address.
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MOVSIGN"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def MCMPI2R(instruction, block, line_number, graph, graphH):

	#mov dest, src1, src2  ==> dest = src1 <- src2 ==> merge contents of src1 and src2 and store in destination address.
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MCMPI2R"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def MOVI (instruction, block, line_number, graph, graphH):
 #dest = src1 <- imm
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MOVI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	imm  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = imm
	push_stacks(block[3], block[4], block[5], block[6], graph) 
	return block 

def SEXT (instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SEXT"  #Probably not useful
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 



def SEXTI (instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SEXTI"  #Probably not useful
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	imm  = instruction[3]
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = imm
	push_stacks(block[3], block[4], block[5], block[6], graph) 
	return block 	



def ZEXT(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ZEXT"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	zext = "zero_extend" + "(" +src1+","+src2+")"
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def ZEXTI(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ZEXTI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op =   instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2  = instruction[3]
	zext = "zero_extend" + "(" +src1+","+src2+")"
	op_node   = op   + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def RUFLAG(instruction, block, line_number, graph, graphH):
 #
	#Reads the user level flag stored in the bit position specified by the immediate Imm and stores it in the register Dest.
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "RUFLAG"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op = instruction[0]
	dest = instruction[1]
	imm = instruction[2]
	op_node = op + str(line_number)
	micro_ops.append(op_node)
	block[3] = op_node
	block[4] = dest	
	block[5] = imm
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def RUFLAGS(instruction, block, line_number, graph, graphH):
 #Suspend for now
	#Read all user flags.
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "RUFLAGS"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op = instruction[0]
	dest = instruction[1]
	imm = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = imm
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def WRUFLAGS(instruction, block, line_number, graph, graphH):

	#Set the user level flags to the exclusive or of the Src1 and Src2 registers.
	#user flags = SRc1 ^ SRC2
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "WRUFLAGS"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op = instruction[0]
	dest = instruction[1]
	imm = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def MOV2FP(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MOV2FP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = source
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def WRUFLAGSI(instruction, block, line_number, graph, graphH):

	#Set the user level flags to the exclusive or of the Src1 and Imm registers.
	#user flags = SRc1 ^ imm
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "WRUFLAGSI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	imm_shape = "plaintext"
	op = instruction[0]
	dest = instruction[1]
	imm = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = imm
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def RDIP(instruction, block, line_number, graph, graphH):
	#Responsible for taking the ip value %ctrl153 and dumping into the temporary register
	#Read the instruction pointer
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "RDIP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest	
	block[5] = src1
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def WRIP(instruction, block, line_number, graph, graphH):

	#Set the rIP to the sum of the Src1 and Src2 registers. This causes a macroop branch at the end of the current macroop.
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "WRIP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	src1 = instruction[1]
	src2 = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = "rip"
	block[5] = src1
	block.insert(6, src2) 
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def WRIPI(instruction, block, line_number, graph, graphH):

		#Set the rIP to the sum of the Src1 and Src2 registers. This causes a macroop branch at the end of the current macroop.
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "WRIPI"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	src1 = instruction[1]
	src2 = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = "rip"
	block[5] = src1
	block.insert(6, src2)
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def LD(instruction, block, line_number, graph, graphH):

	#Load
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "LD"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest
	block[5] = source
	block.insert(6, "0") 
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def LDFP(instruction, block, line_number, graph, graphH):

	#Load floating point
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "LDFP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def LFPIMM(instruction, block, line_number, graph, graphH):

	#Load floating point
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "LFPIMM"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node 
	block[4] = dest
	block[5] = source 	
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def LDM(instruction, block, line_number, graph, graphH):

	#Load multimedia register
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "LDM"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def LDST(instruction, block, line_number, graph, graphH):

	#Load with store check
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "LDST"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def LDSTL(instruction, block, line_number, graph, graphH):

	#Load with store check locked
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "LDSTL"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def ST(instruction, block, line_number, graph, graphH):

	#Read the instruction pointer
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ST"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	source = instruction[1]
	dest = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def STF(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "STF"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	source = instruction[1]
	dest = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def STFP(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "STFP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	source = instruction[1]
	dest = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def STM(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "STM"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	source = instruction[1]
	dest = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def STUPD(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "STUPD"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	source = instruction[1]
	dest = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def LEA(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "LEA"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def CDA(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "CDA"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def CDAF(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "CDAF"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 



def CIA(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "CIA"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	source_node = source + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def TIA(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "TIA"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def LIMM(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "LIMM"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest
	block[5] = source
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def MOVFP(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MOVFP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = src1  
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def MOV2INT(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MOV2INT"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	source = instruction[2]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = source 
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 

def XORFP(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "XORFP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = src1 
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph) 
	return block 

#def SQRTFP
def ADDFP(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "ADDFP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = src1 
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph) 
	return block 


def SUBFP(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "SUBFP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = src1 
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph) 
	return block 


def MULFP(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MULFP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = src1 
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph) 
	return block 



def DIVFP(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "DIVFP"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = src1 
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph) 
	return block 


def COMPFP(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def CVTF_I2D(instruction,line_number, graph):
	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def CVTF_I2D_HI(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def CVTF_D2I(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def FAULT(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def LDDHA(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 


def LDAHA(instruction, block, line_number, graph, graphH):

	for item in instruction:
		no_dfg.write("%s" %(item))
		no_dfg.write("\n")
	return block 

def  BR(instruction, block, line_number, graph, graphH):

	#br
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "BR"
	op_shape = "box"
	node = "node"
	imm_shape = "plaintext"
	op  =   instruction[0]
	imm =   instruction[1]
	op_node  = op  + str(line_number)
	block[3] = op_node
	block[4] = imm  
	block.insert(5, "0")
	block.insert(6, "0")
	push_stacks(block[3], block[4], block[5], block[6], graph)
	return block 


def MADDF(instruction, block, line_number, graph, graphH):

	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "maddf"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = src1 
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph) 
	return block 



def MMULF(instruction, block, line_number, graph, graphH):
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	label = "MMULF"
	op_shape = "box"
	node = "node"
	reg_shape = "circle"
	op = instruction[0]
	dest = instruction[1]
	src1 = instruction[2]
	src2 = instruction[3]
	op_node = op + str(line_number)
	dest_node = dest + str(line_number)
	block[3] = op_node
	block[4] = dest  
	block[5] = src1 
	block[6] = src2
	push_stacks(block[3], block[4], block[5], block[6], graph) 
	return block 



def CHECK_TEMP(instruction):  #Removed {line_number, graph}
	temp_registers =[	"t0d",  "t1d",  "t2d",  "t3d",  "t4d",  "t5d", "t6d", "t7d", "t8d", "t9d",
						"t0w",  "t1w",  "t2w",  "t3w",  "t4w",  "t5w", "t6w", "t7w", "t8w", "t9w",
				 		"t0",   "t1",   "t2",   "t3",   "t4",   "t5",  "t6",  "t7",  "t8",  "t9" ]
	temp_set = set(temp_registers)
	while '' in instruction:
		instruction.remove('')
	counter = 0
	l = len(instruction)
	i = 0
	try:
		while instruction[i]: #while in the list containing instruction
			if instruction[i] in temp_registers: #if the instruction with index i is a temp_register
				instruction = list(filter(lambda x: x != instruction[i], instruction)) #remove it
			i += 1
	except IndexError:
		pass
	return instruction





operatorsX86 = {	"add" 	: ADD,
					"addi" 	: ADDI,
					"adc" 	: ADC,
					"adci"  : ADCI,
					"sub"   : SUB,
					"subi"   : SUBI,
					"mul1s"   : MUL1S,
					"mul1si"   : MUL1SI,
					"mul1u"   : MUL1U,
					"mul1ui"   : MUL1UI,
					"mulel"   : MULEL,
					"muleh"   : MULEH,
					"or"   : OR,
					"ori"   : ORI,
					"xor"   : XOR,
					"mxor"  : MXOR,
					"xori"   : XORI,
					"and"   : AND,
					"andi"   : ANDI,
					"sll"   : SLL,
					"slli"   : SLLI,
					"srl"   : SRL,
					"srli"   : SRLI,
					"sra"   : SRA,
					"srai"   : SRAI,
					"ror"   : ROR,
					"rori"   : RORI,
					"rcri"   : RCRI,
					"rol"   : ROL,
					"roli"   : ROLI,
					"rcl"   : RCL,
					"rcli"   : RCLI,
					"mov"   : MOV,
					"movsign" : MOVSIGN,
					"mov2int" : MOV2INT,
					"mcmpi2r" : MCMPI2R,
					"movi"   : MOVI,
					"sext"   : SEXT,
					"sexti" : SEXTI,
					"zext"   : ZEXT,
					"zexti"  : ZEXTI,
					"ruflag"   : RUFLAG,
					"ruflags"   : RUFLAGS,
					"wruflags"   : WRUFLAGS,
					"wruflagsi"   : WRUFLAGSI,
					"rdip"   : RDIP,
					"wrip"   : WRIP,
					"wripi"   : WRIPI,
					"ld"   : LD,
					"ldfp"   : LDFP,
					"lfpimm" : LFPIMM,
					"ldm"   : LDM,
					"ldst"   : LDST,
					"ldstl"   : LDSTL,
					"st"   : ST,
					"stf"   : STF,
					"stfp" : STFP,
					"stm"   : STM,
					"stupd"   : STUPD,
					"lea"   : LEA,
					"cda"   : CDA,
					"cdaf"   : CDAF,
					"cia"   : CIA,
					"tia"   : TIA,
					"limm"   : LIMM,
					"movfp"   : MOVFP,
					"mov2fp"  : MOV2FP,
					"xorfp"   : XORFP,
					"addfp"   : ADDFP,
					"subfp"   : SUBFP,
					"mulfp"   : MULFP,
					"divfp"   : DIVFP,
					"compfp"   : COMPFP,
					"cvtf_i2d"   : CVTF_I2D,
					"cvtf_i2d_hi"   : CVTF_I2D_HI,
					"cvtf_"   : CVTF_D2I,
					"fault"   : FAULT,
					"lddha"   : LDDHA,
					"ldaha"   : LDAHA,
					"br"   	  : BR,
					"maddf"   : MADDF,
					"mmulf"   : MMULF  }

#Used to have temp_registers here
def sanitizer(elements):
	sanitized = map(lambda x: s.strip(), elements)
	return elements

def initialize_row_matrix(matrix, index): #Returns a matrix of (["0"], ["0"],["0"], ["0"],["0"], ["0"])
	for i in range(len(matrix[index])):
		matrix.append("0")
	return matrix 


def moveTopHead():
	from_path = os.getcwd()
	topfile = from_path + '/TopHead.h'
	to_path = from_path + '/CFiles/'
	os.system("mv %s %s"%(topfile, to_path))	

def moveHeaders():
	from_path = os.getcwd()
	topfile = from_path + '/Blocks/*.h'
	to_path = from_path + '/CFiles/'
	os.system("mv %s %s"%(topfile, to_path))

def read_trace():
	counter = 1  #counter for each line of file
	count = 0      #{Count for each item in list more of like an index for elements}
	founds = 0
	Block_matrix = [] #local matrix
	line_list2 = []  #Personal note {don't forget to register list to prevent exceptions}
	not_founds = 0
	refined_list= []
	refined_list2 = []
	pattern = "0x"
	gi = 0
	moveTopHead()
	for name in files:
		try:
			graph = open(name+'.cpp', 'a')
			graphH = open(name+'.h', 'a')
			graphH.write("#include \"TopHead.h\"")
			EnumTableHead(graphH)
			header = re.findall(r'\d+', name)
			graph.write("\n#include \"%s.h\"\n"%(" ".join(str(x) for x in header )))
			graph.write("int main(){\n")
			p = inflect.engine()
			dotfile = p.number_to_words(" ".join(str(x) for x in header ))
			#graph.write("ofstream %s;\n"%(" ".join(str(x) for x in header )))
			graph.write("ofstream %s;\n" %(dotfile))
			dotfiledot = dotfile + ".dot"
			graph.write("%s.open(\"%s.dot\");\n"%(dotfile, dotfile))
			graph.write("%s<<\"digraph %s{\"<<endl;"%(dotfile, dotfile))
			#graph.write("%s.open (\"%s.dot\");"%( (" ".join(str(x)  for x in header )), (" ".join(str(x)  for x in header ))) )
			graph.write("vector <string> ABSOLUTE_ADDRESS;\n")
			graph.write("vector <string> RELATIVE_ADDRESS;\n")
			graph.write("vector <string> MACROS;\n")
			graph.write("vector <string> op_nodes;\n")
			graph.write("vector <string> dest;\n")
			graph.write("vector <string> src1;\n")
			graph.write("vector <string> src2;\n")
			with open(name, 'r') as f:
				text = f.readlines()
				for line in text:  #For each line the the assembly file do the following
					counter = counter + 1
					if re.match( r'(.*)0x[a-zA-Z0-9](.*?) .*', line, re.M | re.I):   #Check to see if the first two characters are 0x {more accurate}
						line_list 	= line.split(":")  #Turn each line into a list of words for text processing
						#print (counter)
						refined_list = line_list[3].split(' ') #get the actuall micro_instruction
						line_list = [x.strip(' ') for x in line_list]	#Remove all spaces
						line_list = filter(bool, line_list)				#filter once more to remove spaces agaain
						refined_list = [x.strip(' ') for x in refined_list] # Keep striping
						refined_list = filter(bool, refined_list)  # Remove all spaces
						refined_list = [x.strip(',') for x in refined_list]  #Strip list from all commas, I hate them
						really_refined = map(str.strip, refined_list)
						#After splitting get the absolute address, relative address, macro, instruction
						Block_matrix.append([])
						Block_matrix[gi].append(line_list[0])
						Block_matrix[gi].append(line_list[1])
						Block_matrix[gi].append(line_list[2])
						#Now load micro ops, dest, src1 and src2
						for i in range(len(refined_list)):
							Block_matrix[gi].append(refined_list[i])
						Bl = len(Block_matrix[gi]) #get length of Block_matrix
						while '\n' in Block_matrix[gi]:
							Block_matrix[gi].remove('\n')
						while '' in Block_matrix[gi]:
							Block_matrix[gi].remove('')
						
						if refined_list[0] in operatorsX86:
							line = str(counter)
							Block_matrix[gi] = operatorsX86[refined_list[0]](refined_list, Block_matrix[gi],  counter, graph, graphH)
							#found_ops.write(refined_list[0] + '\n')
							#graphity(Block_matrix)
							gi = gi + 1
							#instructions_file.write("absolute_address: %s, instruction: %s, line_number: %s\n"  %(refined_absolute(line_list[0]), refined_list, line))
									#count = count + 1  #Count number of items in assembly code so ex: {lea r10, DS} will have 3 items
						else:
									#print ("operator (not found) = %s line => number = %d "%(refined_list[i], counter))
							not_found_ops.write(refined_list[0] + '\n')  #Report if operator not found into not_found.md file}
							gi = gi + 1
				#graphity(Block_matrix, graph)
			#instructions_file.write("-------------------End of %s Block-----------------------------\n" %(name))

									#count = count + 1
			#print ("Number of operators in table = %d\nNumber of operators not in table = %d\n" %(founds, not_founds))
			#print ("Total number of lines in assemblyfile %d" %(counter) )
			#print ("Percentage of operators in lookup table = %f" %(percentage(founds, counter)))
			EnumTableTail(graphH)
			graph.write("\nGraph gh(%s);\n"%(str(gi)))
			__IMPLEMENT_GRAPH__(graph, dotfile)
			graph.write("\ngh.printGraph();\n")
			graph.write("%s<<\"}\"<<endl;"%(dotfile))
			graph.write("")
			__CPP_FOOTER__(graph)
			#finalizer_graph(graph)
			gi = 0
						#around here call a function to generate blocks in output directory
						#os.system('mv %s.dot Graphs/%s.dot' %(name,name))
						#another command to actually generate the pictorial graph itself
						#Done
		except IOError as exc:
			if exc.errno != errno.EISDIR:
				raise

	#for i in dest_nodes:
	#	del i
	#for i in dest_node_labels:
	#	del i

#		except IOError as exc:
#			if exc.errno != errno.EISDIR:
#				raise


def find_operator(line_list, operators):
		#return any([i in operator_list for i in line_list])
		#return not (set(line_list).disjoint(operators))
		if any([item in line_list for item in operatorsX86]):
				return 1
		else:
				return 0


def file_initializer(pfile, *pfiles):
		#with open(pfile, "w"):
				#pass
		pfile.seek(0)
		pfile.truncate()
		for index in range(len(pfiles)):
				pfiles[index].seek(0)
				pfiles[index].truncate()


def keyword_match(keyword):
		a_starts = sorted(keyword[:-1] for keyword in operatorsX86)
		pos = bisect_right(a_starts, keyword)
		matched_keyword = a_starts[pos-1]
		return matched_keyword if  keyword.startswith(matched_keyword) else None

		#for keyword in assemblyfile:
		#       print(keyword)

def percentage(part, whole):
		return 100 * float(part)/ float(whole)


def moveC():
	current_path = os.getcwd()
	input_path = current_path + '/Blocks/*.cpp'
	output_path = current_path + '/CFiles/'
	os.system('mv %s %s' %(input_path, output_path))


def moveG():
	current_path = os.getcwd()
	input_path = current_path + '/Blocks/*.dot'
	output_path = current_path + '/Graphs/'
	os.system('mv %s %s' %(input_path, output_path))

def createps():
	input_path = os.getcwd()
	n = 0
	input_path = input_path + '/CFiles/*'
	dot_files = []
	for files in os.walk(input_path):
		for dot_file in files:
			file_path = ('/CFiles/%s'%(dot_files))
			os.system('dot -Tps %s -o Graphs/graph%d.ps'%(file_path, n  ))
			n += 1
	#os.system('/Blocks/*.dot  /Graphs/')


'''
def RunCpp():
	input_path = os.getcwd()
	n = 0
	input_path = input_path + 'CFiles/*'
	cfiles = []
	for files in os.walk(input_path):
		for cfile in files:
			file_path = ('/CFiles/%s'%(cfiles))
			#os.system('g++ %s'%(file_path, n))
			n = n + 1
'''
def create_shell():
	input_path = os.getcwd()
	n = 0
	input_path = input_path + '/Graphs/*'
	ps_shellscript = "gpg.sh"
	script = open(input_path+'gpg.sh', 'a')
	script.write("#!/bin/sh\n")
	script.write("for file in ./*.c\n")
	script.write("do\n")
	script.write('\tdot -Tps "${filename}" -o "new${filename}" \n')
	script.write("done\n")


#initializer_graph()
#upload(prompt)
read_trace()
#regularexpress()
found_ops.close()
not_found_ops.close()
moveC()
moveHeaders()
#moveG()
#create_shell()
#moveTopHead()
#test = open("testing.h", 'a+')
#CREATE_LOOKUP_TABLE(test)
#os.system("python cleaner_guy.py")
#__print_dest_list__()
#finalizer_graph()
#print operators

#https://github.com/uart/gem5-mirror/tree/master/src/arch/generic
#http://www.gem5.org/X86_microop_ISA#Xor
#http://permalink.gmane.org/gmane.comp.emulators.m5.devel/4508
#https://github.com/xflr6/graphviz/blob/master/examples/notebook.ipynb
#https://docs.python.org/3.1/library/stdtypes.html#str.isspace
#http://www.cyberciti.biz/faq/python-command-line-arguments-argv-example/
#https://github.com/codypierce/pyemu/blob/master/PyCPU.py
"""
 array = []
>>> array.append([])
>>> array[0].append("0x4375f8.0")
>>> array[0].append("@main+245.0")
>>> array[0].append("CMP_M_I")
>>> array[0].append("sub")
>>> array[0].append("t0d")
>>> array[0].append("t1d")
>>> array[0].append("t2d")
>>> array
[['0x4375f8.0', '@main+245.0', 'CMP_M_I', 'sub', 't0d', 't1d', 't2d']]
>>> exit()

"""
#http://codereview.stackexchange.com/questions/77544/graph-implementation-adjacency-list-2-0

#__author__ = 'Robert'

#from bisect import bisect_right

#file_a = hell*
#wor*
#howard*
#are*
#yo*
#all*
#to*""".splitlines()

#file_b = """hello world how are you all today too told town""".split()

#a_starts = sorted(word[:-1] for word in file_a) #can do this easily if only 100, 000 words as you say.

#def match(word):
 #   pos = bisect_right(a_starts, word)
	#assert 0 <= pos < len(a_starts)
  #  matched_word = a_starts[pos - 1]
   # return matched_word if word.startswith(matched_word) else None

#for word in file_b:
 #   print(word, " -> ", match(word))


#hello  ->  hell
#world  ->  wor
#how  ->  None
#are  ->  are
#you  ->  yo
#all  ->  all
#today  ->  to
#too  ->  to
#told  ->  to
#town  ->  to


 #               if find_operator(refined_list, operatorsX86):
						#print refined_list[0]+"  was found in table"
 #                        op_grapher = Opgrapher(refined_list[0])
						#op_grapher.operators_x86[refined_list[0]]
 #                        elif keyword_match(line_list, counter) == None:
  #                               e.write("%s not found in table in line %d\n" %(refined_list[0], counter) )
  #                       else:
								#print("%s not found in table in line %d" %(refined_list[0], counter) )
  #                               e.write("%s not found in table in line %d\n" %(refined_list[0], counter) )
   #                              continue
#"""
#a = open (raw_file, "r") {I used for code testing not valid anymore maybe next time}
	#while True:
		#try:
			#trace_file = raw_input("Please enter the name of the trace file: ")
		#except ValueError:
			#print("Sorry, the file you entered %s doesnot exist try again" %(trace_file))
			#continue
		#else:
			#breakwhile True:

#def upload(prompt):
#    trace_file = raw_input(prompt)
#    if(os.path.exists(trace_file)):
#        read_trace(trace_file)
#    else:
#        print ("The file you entered does not exist\n")
#        print ("Press Enter to continue....\n")
#        upload(prompt)

##Ask user for input
#raw_input("Please enter the nmae of trace file within current directory: ")
#upload("Yes you got it: ")

#Playing with regular expressions seeing which one suites this design
#def regularexpress():
#	pattern = "0x"
#	trace_file = open("fftX86_output", 'r')
#	text = trace_file.readlines()
#	for line in text:
#		if re.match( r'(.*)0x[a-zA-Z0-9](.*?) .*', line, re.M | re.I):
#		print line

#import sys
#import glob
#import errno

#input_path = 'Blocks/*'
#files = glob.glob(input_path)
#for name in files:		# 'file' is a builtin type, 'name' is a less-ambiguous variable name.
#	try:
#		with open(name) as f:  # No need to specify 'r': this is the default.
#			sys.stdout.write(f.read())
#	except IOError as exc:
#		if exc.errno != errno.EISDIR: # Do not fail if a directory is found, just ignore it.
#			raise #Propagate other kinds of IOError

#Remember to generate dump file >> obj_dump -D file_name.out > dump_output
